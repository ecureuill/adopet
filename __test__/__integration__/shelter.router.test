import request from 'supertest';
import { Server } from 'http';
import { randomUUID } from 'crypto';

import { Assertions } from '../../utils/Assertions';
import { HTTP_RESPONSE } from '../../utils/consts';
import { cleanAndSeedDatabase, cleanDatabase, findShelterByUserEmail } from '../../utils/database';
import { findShelterUserAndCreateToken, findTutorUserAndCreateToken, getTokens } from '../../utils';

import { startServer } from '../../../src/server';
import { closeConnection, openConnection } from '../../../src/database/datasource/data-source';
import { Shelter } from '../../../src/entities/Shelter';
import { Pet } from '../../../src/entities/Pet';
import { IPet, IShelter } from '../../../src/types/schemas';
import { Role } from '../../../src/types/enums';

let server: Server;
let tokenAdmin: string;
let tokenShelter: string;
let tokenTutor: string;
let ids: {
	admins: string[], 
	tutors: string[], 
	shelters: string[],
	pets: string[]
};

beforeAll(async () => {
	server = startServer();
	await openConnection();
	await cleanDatabase();
	ids = await cleanAndSeedDatabase(3);
	({ tokenShelter, tokenAdmin, tokenTutor } = await getTokens());
});

afterAll(() => {
	server.close();
	closeConnection();
});

describe('Router to signup shelter', () => {
	it('responds CREATED and body should have an user object to /signup/abrigos', async () => {
		const payload = {
			user: {
				name: 'shelter test',
				email: 'shelter_test@mail.com',
				password: '12345678'
			}
		};

		const result = {
			delete_date: null,
			user: {
				email: payload.user.email,
				name: payload.user.name,
				role: 'tutor',
				phone: null,
				city: null,
				state: null,
				delete_date: null,
			}
		};

		const res = await request(server)
			.post('/signup/abrigos')
			.send(payload)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json');

		console.debug(`Assertion.created\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.created(res, result);
	});

	it('responds BADREQUEST to post /signup/abrigos with already registered existed email', async () => {
		const payload = {
			user: {
				name: 'shelter test',
				email: 'shelter_test@mail.com',
				password: '12345678'
			}
		};

		const res = await request(server)
			.post('/signup/abrigos')
			.send(payload)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json');

		console.debug(`Assertion.signUPNotAllowed\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.signUPNotAllowed(res);
	});

	it('responds BadRequest to post /signup/abrigos with wrong json schema', async () => {
		const payload = {
			a: 'shelter test',
			b: 'shelter_test1@mail.com',
		};

		const res = await request(server)
			.post('/signup/abrigos')
			.send(payload)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json');

		console.debug(`Assertion.jsonSchemaError\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.jsonSchemaError(res);
	});

});

describe('Router to retrieve ahelters', () => {
	it('responds OK and body should have a list of shelters when admin user get /abrigos', async () => {

		const res = await request(server)
			.get('/abrigos')
			.set('Authorization', `Bearer ${tokenAdmin}`);

		console.debug(`Assertion.retrieveCompleteListEntities\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.retrieveCompleteListEntities(res);
	});

	it('responds OK and body should have a list of shelters when unauthenticated-user get /abrigos', async () => {

		const res = await request(server)
			.get('/abrigos');

		console.debug(`Assertion.retrieveCompleteListEntities\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.retrieveCompleteListEntities(res);
	});

	it('responds OK and body should have a list of shelters when shelter-user get /abrigos', async () => {

		const res = await request(server)
			.get('/abrigos')
			.set('Authorization', `Bearer ${tokenShelter}`);

		console.debug(`Assertion.retrieveCompleteListEntities\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.retrieveCompleteListEntities(res);
	});

	it('responds OK and body should have a list of shelters when tutor-user get /abrigos', async () => {

		const res = await request(server)
			.get('/abrigos')
			.set('Authorization', `Bearer ${tokenTutor}`);

		console.debug(`Assertion.retrieveCompleteListEntities\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.retrieveCompleteListEntities(res);
	});
});

describe('Router to retrieve a shelter by id', () => {

	let shelter: Shelter;

	beforeAll(async () => {
		shelter = await Shelter.findOneOrFail( {where: {id: ids.shelters[0]}, relations: { user: true, pets: true}});
	});

	it('responds OK and body should have one shelter when admin user get /abrigos/:id', async () => {

		const res = await request(server)
			.get(`/abrigos/${ids.shelters[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`);

		console.debug(`Assertion.retrieveEntity\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.retrieveEntity(res, shelter);
	});

	it('responds OK and body should have one shelter when tutor-user get /abrigos/:id', async () => {

		const res = await request(server)
			.get(`/abrigos/${ids.shelters[0]}`)
			.set('Authorization', `Bearer ${tokenTutor}`);

		const { id, userId, user, pets, ...partialShelter } = shelter;
		const { id: idUser, password, ...partialUser } = user;
		const partialPets = pets.reduce((prev: any, curr: Pet) => {
			const { id, shelter, shelterId, ...partial } = curr;

			return prev.push(partial);
		}, []);

		console.debug(`Assertion.retrieveEntity\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.retrieveEntity(res, {...partialShelter, user: partialUser, pets: partialPets});
	});

	it('responds OK and body should have one shelter when shelter-user get /abrigos/:id', async () => {

		const res = await request(server)
			.get(`/abrigos/${ids.shelters[0]}`)
			.set('Authorization', `Bearer ${tokenShelter}`);

		const { id, userId, user, pets, ...partialShelter } = shelter;
		const { id: idUser, password, ...partialUser } = user;
		const partialPets = pets.reduce((prev: any, curr: Pet) => {
			const { id, shelter, shelterId, ...partial } = curr;

			return prev.push(partial);
		}, []);

		console.debug(`Assertion.retrieveEntity\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.retrieveEntity(res, {...partialShelter, user: partialUser, pets: partialPets});
	});

	it('responds OK and body should have one shelter when unauthenticated-user get /abrigos/:id', async () => {

		const res = await request(server)
			.get(`/abrigos/${ids.shelters[0]}`);

		const { id, userId, user, pets, ...partialShelter } = shelter;
		const { id: idUser, password, ...partialUser } = user;
		const partialPets = pets.reduce((prev: any, curr: Pet) => {
			const { id, shelter, shelterId, ...partial } = curr;

			return prev.push(partial);
		}, []);

		console.debug(`Assertion.retrieveEntity\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.retrieveEntity(res, {...partialShelter, user: partialUser, pets: partialPets});
	});

	it('responds OK and body has "Não Encontrado" when user get /abrigos/:id with non-existent id', async () => {

		const res = await request(server)
			.get(`/abrigos/${randomUUID()}`)
			.set('Authorization', `Bearer ${tokenAdmin}`);

		console.debug(`Assertion.nonExistentId\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.nonExistentId(res);
	});
});

describe('Router to update (put) a shelter by id', () => {
	let shelter: Shelter;
	let payload: IShelter;
	
	beforeAll(async () => {
		shelter = await Shelter.findOneOrFail({
			where: {id: ids.shelters[0]}, 
			relations: { user: true, pets: true}
		});

		payload = {
			id: shelter.id,
			userId: shelter.userId,
			pets: [
				{
					adopted: false,
					age: 1,
					age_unit: 'y', 
					name: `pet_${shelter.id}`,
					size_variety:'m',
					type: 'dog'
				}
			],
			inactive: true,
			user: {
				id: shelter.userId,
				email: 'altered@mail.com',
				name: 'altered',
				password: 'altered1',
				role: Role.TUTOR,
				city: 'altered',
				state: 'AL',
				phone: '11.9999-9999',
			},
		} as IShelter;
	});

	it('responds OK and body should have shelter with updated data, containing created pet, WHEN admin-user put /abrigos/:id', async () => {

		const res = await request(server)
			.put(`/abrigos/${ids.shelters[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		console.debug(`Assertion.putShelterDone\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.putShelterDone(res, payload);

	});

	it('responds OK and body should have shelter with updated data, containing created pet and altered pet, WHEN admin-user put /abrigos/:id', async () => {

		const shelter = await findShelterByUserEmail('abrigo_pet@mail.com');
		console.debug(shelter);
		const pets = shelter.pets.map(p => {
			const {create_date, delete_date, update_date, ...pet} = p;
			return pet;
		});
		const petsPayload: IPet[] = [ {
			adopted: false,
			age: 1,
			age_unit: 'y', 
			name: `pet_${shelter.id}_00`,
			size_variety:'m',
			type: 'dog'
		} as IPet];

		if(pets.length === 0)
			throw new Error('Should have pets');

		petsPayload.push(
			{
				id: pets[0].id,
				shelterId: pets[0].shelterId,
				adopted: !pets[0].adopted,
				age: pets[0].age+1,
				age_unit: 'm', 
				name: `altered_${pets[0].name}`,
				size_variety:'l',
				type: 'cat'
			}
		);
		petsPayload.push(pets[1]);
		petsPayload.push(pets[2]);
		const shelterPayload = {
			id: shelter.id,
			userId: shelter.userId,
			pets: petsPayload,
			inactive: true,
			user: {
				id: shelter.userId,
				email: 'altered@mail.com',
				name: 'altered',
				password: 'altered1',
				role: Role.TUTOR,
				city: 'altered',
				state: 'AL',
				phone: '11.9999-9999',
				delete_date: ''
			},
		} as IShelter;
		console.debug(shelterPayload);

		const res = await request(server)
			.put(`/abrigos/${ids.shelters[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(shelterPayload);

		console.debug(`Assertion.putShelterDone\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.putShelterDone(res, shelterPayload);

	});

	it('responds OK and body should have shelter with updated data (no alteration to pets), WHEN admin-user put /abrigos/:id', async () => {

		const shelter = await findShelterByUserEmail('abrigo_pet@mail.com');
		console.debug(shelter);
		const pets = shelter.pets.map(p => {
			const {create_date, delete_date, update_date, ...pet} = p;
			return pet;
		});

		if(pets.length === 0)
			throw new Error('Should have pets');

		const shelterPayload = {
			id: shelter.id,
			userId: shelter.userId,
			pets: pets,
			inactive: true,
			user: {
				id: shelter.userId,
				email: 'altered@mail.com',
				name: 'altered',
				password: 'altered1',
				role: Role.TUTOR,
				city: 'altered',
				state: 'AL',
				phone: '11.9999-9999',
				delete_date: ''
			},
		} as IShelter;
		console.debug(shelterPayload);

		const res = await request(server)
			.put(`/abrigos/${ids.shelters[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(shelterPayload);

		console.debug(`Assertion.putShelterDone\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.putShelterDone(res, shelterPayload);

	});

	it('responds OK and body should have shelter with no alteration to data, WHEN admin-user put /abrigos/:id', async () => {

		const shelter = await findShelterByUserEmail('abrigo_pet@mail.com');
		console.debug(shelter);

		const {delete_date,...shelterPayload} = shelter;
		shelterPayload.pets = shelter.pets.map(p => {
			const { create_date, delete_date, update_date, ...pet } = p;
			return pet;
		}) as Pet[];
		console.debug(shelterPayload);

		const res = await request(server)
			.put(`/abrigos/${ids.shelters[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(shelterPayload);

		console.debug(`Assertion.putShelterDone\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.putShelterDone(res, shelterPayload);

	});


	it('responds OK and body has "Não Encontrado" when put /abrigos/:id with non-existent id', async () => {
		const randId = randomUUID();
		const res = await request(server)
			.get(`/abrigos/${randId}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({
				...payload,
				id: randId
			});

		console.debug(`Assertion.nonExistentId\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.nonExistentId(res);
	});

	it('responds UNAUTHORIZED when unauthenticated user put /abrigos/:id', async () => {

		const res = await request(server)
			.put(`/abrigos/${ids.shelters[0]}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		console.debug(`Assertion.unauthenticated\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.unauthenticated(res);
	});

	it('responds FORBIDDEN when shelter-user owner of resource put /abrigos/:id', async () => {

		const res = await request(server)
			.put(`/abrigos/${ids.shelters[0]}`)
			.set('Authorization', `Bearer ${await findShelterUserAndCreateToken(ids.shelters[0])}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		console.debug(`Assertion.notAllowedEntityUpdate\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.notAllowedEntityUpdate(res);
	});

	it('responds FORBIDDEN when tutor-user put /abrigos/:id', async () => {

		const res = await request(server)
			.put(`/abrigos/${ids.shelters[0]}`)
			.set('Authorization', `Bearer ${tokenTutor}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		console.debug(`Assertion.notAllowedRole\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.notAllowedRole(res);
	});

	it('responds FORBIDDEN when shelter-user not onwer of resource put /abrigos/:id', async () => {

		const res = await request(server)
			.put(`/abrigos/${ids.shelters[0]}`)
			.set('Authorization', `Bearer ${tokenShelter}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		console.debug(`Assertion.restrictedToOwner\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.restrictedToOwner(res);
	});

	it('responds BADREQUEST When user put /abrigos/:id with replaced id', async () => {

		const res = await request(server)
			.put(`/abrigos/${ids.shelters[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, id: randomUUID()});

		console.debug(`Assertion.idReplacement\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.idReplacement(res);
	});

	it('responds BADREQUEST when user put /abrigos/:id with replaced userId', async () => {

		const res = await request(server)
			.put(`/abrigos/${ids.shelters[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, userId: randomUUID()});

		console.debug(`Assertion.idReplacement\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.idReplacement(res);
	});

	it('responds BADREQUEST When user put /abrigos/:id with replaced user.id', async () => {

		const res = await request(server)
			.put(`/abrigos/${ids.shelters[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, user: {id: randomUUID()}});

		console.debug(`Assertion.idReplacement\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.idReplacement(res);
	});

	it('responds BADREQUEST When user put /abrigos/:id with wrong schema', async () => {

		const res = await request(server)
			.put(`/abrigos/${ids.shelters[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, any: 'some'});

		console.debug(`Assertion.jsonSchemaError\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.jsonSchemaError(res);
	});
});

describe('Router to update (patch) a shelter by id', () => {
	const payload = {
		inactive: true,
		user: {
			email: 'altered@mail.com',
			password: 'altered1',
			phone: '11.9999-9999',
		},
		pets: [
			{
				adopted: false,
				age: 1,
				age_unit: 'y', 
				name: `pet_${ids.shelters[1]}`,
				size_variety:'m',
				type: 'dog'
			}
		]
	};

	it('responds OK when adm-user patch /abrigos/:id with any property', async () => {
		const shelter = await Shelter.findOneOrFail( {where: {id: ids.shelters[1]}, relations: { user: true, pets: true}});

		const res = await request(server)
			.patch(`/abrigos/${ids.shelters[1]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		console.debug(`Assertion.patch\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.patchShelterDone(res, shelter, payload as Shelter);
	});

	it('responds OK when shelter-user owner of resource patch /abrigos/:id with permitted property', async () => {

		const shelter = await Shelter.findOneOrFail({
			relations: {
				user: true,
				pets: true,
			}, 
			where: {
				id: ids.shelters[1]
			}
		});
		
		const payload = {
			user: {
				city: 'altered',
			},

			inactive: !shelter.inactive,
		};

		const res = await request(server)
			.patch(`/abrigos/${ids.shelters[1]}`)
			.set('Authorization', `Bearer ${await findShelterUserAndCreateToken(ids.shelters[1])}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		console.debug(`Assertion.patch\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.patchShelterDone(res, shelter, payload as Shelter);
	});

	it('responds FORBIDDEN to shelter-user owner of resource patch /abrigos/:id with any property', async () => {
		
		const res = await request(server)
			.patch(`/abrigos/${ids.shelters[1]}`)
			.set('Authorization', `Bearer ${await findShelterUserAndCreateToken(ids.shelters[1])}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		console.debug(`Assertion.notAllowedPropertyUpdate\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.notAllowedPropertyUpdate(res);

	});

	it('responds FORBIDDEN to shelter-user not onwer of resource patch /abrigos/:id', async () => {
		const payload = {
			user: {
				phone: '11.9999-9999',
			},
			about: 'altered',
		};

		const res = await request(server)
			.patch(`/abrigos/${ids.shelters[1]}`)
			.set('Authorization', `Bearer ${tokenShelter}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		console.debug(`Assertion.restrictedToOwner\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.restrictedToOwner(res);

	});

	it('responds UNAUTHORIZED to unauthenticated-user patch /tutor:id', async () => {
		const res = await request(server)
			.patch(`/abrigos/${ids.shelters[1]}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		console.debug(`Assertion.unauthenticated\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.unauthenticated(res);
	});

	it('responds UNAUTHORIZED to tutor-user patch /tutor:id', async () => {
		const res = await request(server)
			.patch(`/abrigos/${ids.shelters[1]}`)
			.set('Authorization', `Bearer ${tokenTutor}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		console.debug(`Assertion.notAllowedRole\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.notAllowedRole(res);
	});

	it('responds BADREQUEST When a user patch /abrigos/:id with replaced id', async () => {

		const res = await request(server)
			.patch(`/abrigos/${ids.shelters[1]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, id: randomUUID()});

		console.debug(`Assertion.idReplacement\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.idReplacement(res);
	});

	it('responds BADREQUEST When a user patch /abrigos/:id with replaced userId', async () => {

		const res = await request(server)
			.patch(`/abrigos/${ids.shelters[1]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, userId: randomUUID()});

		console.debug(`Assertion.idReplacement\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.idReplacement(res);
	});

	it('responds BADREQUEST When a user patch /abrigos/:id with replaced user.id', async () => {

		const res = await request(server)
			.patch(`/abrigos/${ids.shelters[1]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, user: {id: randomUUID()}});

		console.debug(`Assertion.idReplacement\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.idReplacement(res);
	});

	it('responds BADREQUEST When a user patch /abrigos/:id with wrong schema', async () => {

		const res = await request(server)
			.patch(`/abrigos/${ids.shelters[1]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, any: 'some'});

		console.debug(`Assertion.jsonSchemaError\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.jsonSchemaError(res);
	});

	it('responds BADREQUEST When a user patch /abrigos/:id with non-existent id', async () => {

		const res = await request(server)
			.patch(`/abrigos/${randomUUID()}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		console.debug(`Assertion.nonExistentId\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.nonExistentId(res);
	});
});

describe('Router do delete a shelter by id', () => {

	it('responds UNAUTHORIZED when unauthenticated user delete /abrigos/:id', async () => {
		const res = await request(server)
			.delete(`/abrigos/${ids.shelters[1]}`);

		console.debug(`Assertion.unauthenticated\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.unauthenticated(res);
	});

	it('responds FORBIDDEN when not-admin user delete /abrigos/:id', async () => {
		let res = await request(server)
			.delete(`/abrigos/${ids.shelters[1]}`)
			.set('Authorization', `Bearer ${tokenTutor}`);

		console.debug(`Assertion.notAllowedRole\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.notAllowedRole(res);

		res = await request(server)
			.delete(`/abrigos/${ids.shelters[1]}`)
			.set('Authorization', `Bearer ${tokenShelter}`);

		console.debug(`Assertion.notAllowedRole\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.notAllowedRole(res);
	});

	it('responds OK and body should have delete_date when adm user delete /abrigos/:id', async () => {

		const res = await request(server)
			.delete(`/abrigos/${ids.shelters[1]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`);

		console.debug(`Assertion.delete\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.delete(res);
	});

	it('responds BADREQUEST when user delete /abrigos/:id already deleted', async () => {
		const res = await request(server)
			.delete(`/abrigos/${ids.shelters[1]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`);

		console.debug(`Assertion.nonExistentId\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.nonExistentId(res);

	});
	it('responds BADREQUEST when user delete /abrigos/:id non-existent id', async () => {
		const res = await request(server)
			.delete(`/abrigos/${randomUUID()}`)
			.set('Authorization', `Bearer ${tokenAdmin}`);

		console.debug(`Assertion.nonExistentId\n${res.statusCode}`);
		console.debug(res.body);
		Assertions.nonExistentId(res);
	});
});