import request from 'supertest';
import { Server } from 'http';
import { randomUUID } from 'crypto';

import { Assertions } from '../../utils/Assertions';
import { cleanAndSeedDatabase, cleanDatabase } from '../../utils/database';
import { findTutorUserAndCreateToken, getTokens } from '../../utils';

import { Tutor } from '../../../src/entities/Tutor';
import { ITutor } from '../../../src/types/schemas';
import { Role } from '../../../src/types/enums';
import { startServer } from '../../../src/server';
import { closeConnection, openConnection } from '../../../src/database/datasource/data-source';

let server: Server;
let tokenAdmin: string;
let tokenShelter: string;
let tokenTutor: string;
let ids: {
	admins: string[], 
	tutors: string[], 
	shelters: string[]
};

beforeAll(async () => {
	server = startServer();
	await openConnection();
	await cleanDatabase();
	ids = await cleanAndSeedDatabase(3);
	({ tokenShelter, tokenAdmin, tokenTutor } = await getTokens());
});

afterAll(() => {
	server.close();
	closeConnection();
});

describe('Router to signup tutor user', () => {

	it('Responds CREATED and body should have an user object to post /signup/tutores', async () => {
		const payload = {
			user: {
				name: 'tutor test',
				email: 'tutor_test@mail.com',
				password: '12345678'
			}
		};

		const result = {
			delete_date: null,
			user: {
				email: payload.user.email,
				name: payload.user.name,
				role: 'tutor',
				phone: null,
				city: null,
				state: null,
				delete_date: null,
			}
		};

		const res = await request(server)
			.post('/signup/tutores')
			.send(payload)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json');

		console.debug(res.body);
		Assertions.created(res, result);
	});

	it('responds BADREQUEST to post /signup/tutores with already registered existed email', async () => {
		const payload = {
			name: 'tutor test',
			email: 'tutor_test@mail.com',
			password: '12345678'
		};

		const res = await request(server)
			.post('/signup/tutores')
			.send(payload)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json');

		console.debug(res.body);
		Assertions.signUPNotAllowed(res);
	});

	it('responds BADREQUEST to post /signup/tutores with wrong json schema', async () => {
		const payload = {
			a: 'tutor test',
			b: 'tutor_test1@mail.com',
		};

		const res = await request(server)
			.post('/signup/tutores')
			.send(payload)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json');

		console.debug(res.body);
		Assertions.jsonSchemaError(res);
	});
});

describe('Router to retrieve tutors', () => {
	it('responds OK and body should have a list of tutors when admin user get /tutores', async () => {

		const res = await request(server)
			.get('/tutores')
			.set('Authorization', `Bearer ${tokenAdmin}`);

		Assertions.retrieveCompleteListEntities(res);
	});

	it('responds OK and body has a list containing only one-owned tutor when tutor-user get /tutores ', async () => {

		const res = await request(server)
			.get('/tutores')
			.set('Authorization', `Bearer ${tokenTutor}`);

		Assertions.retrieveRestrictedListOwnedEntities(res);
	});

	it('responds UNAUTHORIZED when unauthenticated-user get /tutores', async () => {

		const res = await request(server)
			.get('/tutores');

		Assertions.unauthenticated(res);
	});

	it('responds FORBIDDEN when shelter-user get /tutores', async () => {

		const res = await request(server)
			.get('/tutores')
			.set('Authorization', `Bearer ${tokenShelter}`);

		Assertions.notAllowedRole(res);
	});
});

describe('Router to retrieve a tutor by id', () => {

	let tutor: Tutor;

	beforeAll(async () => {
		tutor = await Tutor.findOneOrFail( {where: {id: ids.tutors[0]}, relations: { user: true}});
	});

	it('responds OK and body should have one tutor when admin user get /tutores/:id', async () => {

		const res = await request(server)
			.get(`/tutores/${ids.tutors[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`);

		Assertions.retrieveEntity(res, tutor);
	});

	it('responds OK and body should have one tutor when tutor-user owner of the resource get /tutores/:id', async () => {

		const token = await findTutorUserAndCreateToken(ids.tutors[0]);
		const res = await request(server)
			.get(`/tutores/${ids.tutors[0]}`)
			.set('Authorization', `Bearer ${token}`);


		// eslint-disable-next-line @typescript-eslint/no-unused-vars
		const { id: tutorId, userId, user, ...partialTutor } = tutor;
		// eslint-disable-next-line @typescript-eslint/no-unused-vars
		const { id: uId, role, password, ...partialUser } = user;

		const result = {
			user: {...partialUser},
			...partialTutor  
		};

		Assertions.retrieveEntity(res, result);
	});

	it('responds OK and body has "Não Encontrado" when user get /tutores/:id with non-existent id', async () => {

		const res = await request(server)
			.get(`/tutores/${randomUUID()}`)
			.set('Authorization', `Bearer ${tokenAdmin}`);

		Assertions.nonExistentId(res);
	});

	it('responds UNAUTHORIZED when unauthenticated-user get /tutores/:id', async () => {

		const res = await request(server)
			.get(`/tutores/${ids.tutors[0]}`);

		Assertions.unauthenticated(res);
	});

	it('responds FORBIDDEN when tutor-user not owner of resourcer get /tutores/:id', async () => {

		const res = await request(server)
			.get(`/tutores/${ids.tutors[0]}`)
			.set('Authorization', `Bearer ${tokenTutor}`);

		Assertions.restrictedToOwner(res);

	});

	it('responds FORBIDDEN when shelter-user get /tutores/:id', async () => {

		const res = await request(server)
			.get(`/tutores/${ids.tutors[0]}`)
			.set('Authorization', `Bearer ${tokenShelter}`);

		Assertions.notAllowedRole(res);
	});
});

describe('Router to update (put) a tutor by id', () => {
	let tutor: Tutor;
	let payload: ITutor;
	
	beforeAll(async () => {
		tutor = await Tutor.findOneOrFail( {where: {id: ids.tutors[0]}, relations: { user: true}});
		payload = {
			id: tutor.id,
			userId: tutor.userId,
			user: {
				id: tutor.userId,
				email: 'altered@mail.com',
				name: 'altered',
				password: 'altered1',
				role: Role.TUTOR,
				city: 'altered',
				state: 'AL',
				phone: '11.9999-9999',
				delete_date: ''
			},
			about: 'altered',
			photo: undefined
		};
	});

	it('responds OK and body should have tutor with updated date WHEN admin-user put /tutors/:id', async () => {

		const res = await request(server)
			.put(`/tutores/${ids.tutors[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		Assertions.putTutorDone(res, payload);

	});

	it('responds OK and body has "Não Encontrado" when put /tutores/:id with non-existent id', async () => {
		const randId = randomUUID();
		const res = await request(server)
			.get(`/tutores/${randId}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({
				...payload,
				id: randId
			});

		Assertions.nonExistentId(res);
	});

	it('responds UNAUTHORIZED when unauthenticated user put /tutores/:id', async () => {

		const res = await request(server)
			.put(`/tutores/${ids.tutors[0]}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		Assertions.unauthenticated(res);
	});

	it('responds FORBIDDEN when tutor-user owner of resource put /tutores/:id', async () => {

		const res = await request(server)
			.put(`/tutores/${ids.tutors[0]}`)
			.set('Authorization', `Bearer ${await findTutorUserAndCreateToken(ids.tutors[0])}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		Assertions.notAllowedEntityUpdate(res);
	});

	it('responds FORBIDDEN when tutor-user not owner of resaource put /tutores/:id', async () => {

		const res = await request(server)
			.put(`/tutores/${ids.tutors[0]}`)
			.set('Authorization', `Bearer ${tokenTutor}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		Assertions.restrictedToOwner(res);
	});

	it('responds FORBIDDEN when shelter-user put /tutores/:id', async () => {

		const res = await request(server)
			.put(`/tutores/${ids.tutors[0]}`)
			.set('Authorization', `Bearer ${tokenShelter}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		Assertions.notAllowedRole(res);
	});

	it('responds BADREQUEST When user put /tutores/:id with replaced id', async () => {

		const res = await request(server)
			.put(`/tutores/${ids.tutors[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, id: randomUUID()});

		Assertions.idReplacement(res);
	});

	it('responds BADREQUEST when user put /tutores/:id with replaced userId', async () => {

		const res = await request(server)
			.put(`/tutores/${ids.tutors[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, userId: randomUUID()});

		Assertions.idReplacement(res);
	});

	it('responds BADREQUEST When user put /tutores/:id with replaced user.id', async () => {

		const res = await request(server)
			.put(`/tutores/${ids.tutors[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, user: {id: randomUUID()}});

		Assertions.idReplacement(res);
	});

	it('responds BADREQUEST When user put /tutores/:id with wrong schema', async () => {

		const res = await request(server)
			.put(`/tutores/${ids.tutors[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, any: 'some'});

		Assertions.jsonSchemaError(res);
	});

	it('responds BADREQUEST When a user put /tutores/:id with non-existent id', async () => {

		const res = await request(server)
			.put(`/tutores/${randomUUID()}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		Assertions.nonExistentId(res);
	});
});

describe('Router to update (patch) a tutor by id', () => {
	let tutor: Tutor;
	let payload: any;
	
	beforeAll(async () => {
		tutor = await Tutor.findOneOrFail( {where: {id: ids.tutors[1]}, relations: { user: true}});

		payload = {
			about: 'altered',
			user: {
				email: 'altered@mail.com',
				password: 'altered1',
				phone: '11.9999-9999',
			},
		};
	});

	it('responds OK when adm-user patch /tutor/:id with any property', async () => {
		const res = await request(server)
			.patch(`/tutores/${ids.tutors[1]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		Assertions.patchTutorDone(res, tutor, payload);

	});

	it('responds OK when tutor-user owner of resource patch /tutor/:id with permitted property', async () => {
		const payload = {
			user: {
				phone: '11.9999-9999',
			},
			about: 'altered',
		};

		const tutor = await Tutor.findOneOrFail({
			relations: {
				user: true
			}, 
			where: {
				id: ids.tutors[1]
			}
		});

		const res = await request(server)
			.patch(`/tutores/${ids.tutors[1]}`)
			.set('Authorization', `Bearer ${await findTutorUserAndCreateToken(ids.tutors[1])}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		Assertions.patchTutorDone(res, tutor,payload as Tutor);

	});

	it('responds FORBIDDEN to tutor-user patch /tutor/:id for owned resource with any property', async () => {
		
		const tutor = await Tutor.findOneOrFail( {where: {id: ids.tutors[1]}, relations: { user: true}});

		const res = await request(server)
			.patch(`/tutores/${ids.tutors[1]}`)
			.set('Authorization', `Bearer ${await findTutorUserAndCreateToken(ids.tutors[1])}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		Assertions.notAllowedPropertyUpdate(res);

	});

	it('responds FORBIDDEN to tutor-user not onwer of resource patch /tutor/:id', async () => {
		const payload = {
			user: {
				phone: '11.9999-9999',
			},
			about: 'altered',
		};

		const res = await request(server)
			.patch(`/tutores/${ids.tutors[1]}`)
			.set('Authorization', `Bearer ${tokenTutor}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		Assertions.restrictedToOwner(res);

	});

	it('responds UNAUTHORIZED to unauthenticated-user patch /tutor:id', async () => {
		const res = await request(server)
			.patch(`/tutores/${ids.tutors[1]}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		Assertions.unauthenticated(res);
	});

	it('responds UNAUTHORIZED to shelter user patch /tutor:id', async () => {
		const res = await request(server)
			.patch(`/tutores/${ids.tutors[1]}`)
			.set('Authorization', `Bearer ${tokenShelter}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		Assertions.notAllowedRole(res);
	});

	it('responds BADREQUEST When a user patch /tutores/:id with replaced id', async () => {

		const res = await request(server)
			.patch(`/tutores/${ids.tutors[1]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, id: randomUUID()});

		Assertions.idReplacement(res);
	});

	it('responds BADREQUEST When a user patch /tutores/:id with replaced userId', async () => {

		const res = await request(server)
			.patch(`/tutores/${ids.tutors[1]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, userId: randomUUID()});

		Assertions.idReplacement(res);
	});

	it('responds BADREQUEST When a user patch /tutores/:id with replaced user.id', async () => {

		const res = await request(server)
			.patch(`/tutores/${ids.tutors[1]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, user: {id: randomUUID()}});

		Assertions.idReplacement(res);
	});

	it('responds BADREQUEST When a user patch /tutores/:id with wrong schema', async () => {

		const res = await request(server)
			.patch(`/tutores/${ids.tutors[1]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send({ ...payload, any: 'some'});

		Assertions.jsonSchemaError(res);
	});

	it('responds BADREQUEST When a user patch /tutores/:id with non-existent id', async () => {

		const res = await request(server)
			.patch(`/tutores/${randomUUID()}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json')
			.send(payload);

		Assertions.nonExistentId(res);
	});
});

describe('Router do delete a tutor by id', () => {

	it('responds UNAUTHORIZED when unauthenticated user delete /tutores/:id', async () => {
		const res = await request(server)
			.delete(`/tutores/${ids.tutors[1]}`);

		console.debug(res.body);
		Assertions.unauthenticated(res);
	});

	it('responds FORBIDDEN when not-admin user delete /tutores/:id', async () => {
		let res = await request(server)
			.delete(`/tutores/${ids.tutors[1]}`)
			.set('Authorization', `Bearer ${tokenTutor}`);

		console.debug(res.body);
		Assertions.notAllowedRole(res);

		res = await request(server)
			.delete(`/tutores/${ids.tutors[1]}`)
			.set('Authorization', `Bearer ${tokenShelter}`);

		console.debug(res.body);
		Assertions.notAllowedRole(res);
	});

	it('responds OK and body should have delete_date when adm user delete /tutores/:id', async () => {

		const res = await request(server)
			.delete(`/tutores/${ids.tutors[1]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`);

		Assertions.delete(res);
	});

	it('responds BADREQUEST when user delete /tutores/:id already deleted', async () => {
		const res = await request(server)
			.delete(`/tutores/${ids.tutors[1]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`);

		console.debug(res.body);
		Assertions.nonExistentId(res);

	});
	it('responds BADREQUEST when user delete /tutores/:id non-existent id', async () => {
		const res = await request(server)
			.delete(`/tutores/${randomUUID()}`)
			.set('Authorization', `Bearer ${tokenAdmin}`);

		console.debug(res.body);
		Assertions.nonExistentId(res);
	});
});