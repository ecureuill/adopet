import request from 'supertest';
import { Server } from 'http';
import { randomUUID } from 'crypto';

import { Assertions } from '../utils/Assertions';
import { cleanAndSeedDatabase, cleanDatabase } from '../utils/database';
import { findShelterUserAndCreateToken, getTokens } from '../utils';

import { startServer } from '../../src/server';
import { closeConnection, openConnection } from '../../src/database/datasource/data-source';
import { Pet } from '../../src/entities/Pet';
import { IPet } from '../../src/types/schemas';

let server: Server;
let tokenAdmin: string;
let tokenShelter: string;
let tokenTutor: string;
let ids: {
	pets: string[]
};

beforeAll(async () => {
	server = startServer();
	await openConnection();
	await cleanDatabase();
	ids = await cleanAndSeedDatabase(3);
	({ tokenShelter, tokenAdmin, tokenTutor } = await getTokens());
});

afterAll(() => {
	server.close();
	closeConnection();
});

describe('Pet router', () => {
	describe('Router to retrieve pets', () => {
		it('responds OK and body should have a list of pets when admin user get /pets', async () => {

			const res = await request(server)
				.get('/pets')
				.set('Authorization', `Bearer ${tokenAdmin}`);

			Assertions.retrieveCompleteListEntities(res);
		});

		it('responds OK and body should have a list of pets when unauthenticated-user get /pets', async () => {

			const res = await request(server)
				.get('/pets');

			Assertions.retrieveCompleteListEntities(res);
		});

		it('responds OK and body should have a list of pets when shelter-user get /pets', async () => {

			const res = await request(server)
				.get('/pets')
				.set('Authorization', `Bearer ${tokenShelter}`);

			Assertions.retrieveCompleteListEntities(res);
		});

		it('responds OK and body should have a list of pets when tutor-user get /pets', async () => {

			const res = await request(server)
				.get('/pets')
				.set('Authorization', `Bearer ${tokenTutor}`);

			Assertions.retrieveCompleteListEntities(res);
		});
	});

	describe('Router to retrieve a pet by id', () => {

		let pet: Pet;

		beforeAll(async () => {
			pet = await Pet.findOneOrFail( {where: {id: ids.pets[0]}, relations: { shelter: false }});
		});

		it('responds OK and body should have one pet when admin-user get /pets/:id', async () => {

			const res = await request(server)
				.get(`/pets/${ids.pets[0]}`)
				.set('Authorization', `Bearer ${tokenAdmin}`);

			Assertions.retrieveEntity(res, pet);
		});

		it('responds OK and body should have one pet when tutor-user get /pets/:id', async () => {

			const res = await request(server)
				.get(`/pets/${ids.pets[0]}`)
				.set('Authorization', `Bearer ${tokenTutor}`);

			Assertions.retrieveEntity(res, pet);
		});

		it('responds OK and body should have one pet when shelter-user get /pets/:id', async () => {

			const res = await request(server)
				.get(`/pets/${ids.pets[0]}`)
				.set('Authorization', `Bearer ${tokenShelter}`);

			Assertions.retrieveEntity(res, pet);
		});

		it('responds OK and body should have one pet when unauthenticated-user get /pets/:id', async () => {

			const res = await request(server)
				.get(`/pets/${ids.pets[0]}`);

			Assertions.retrieveEntity(res, pet);
		});

		it('responds OK and body has "Não Encontrado" when user get /pets/:id with non-existent id', async () => {

			const res = await request(server)
				.get(`/pets/${randomUUID()}`)
				.set('Authorization', `Bearer ${tokenAdmin}`);

			Assertions.nonExistentId(res);
		});
	});

	describe('Router to update (put) a pet by id', () => {
		let pet: Pet;
		let payload: IPet;
		
		beforeAll(async () => {
			pet = await Pet.findOneOrFail({
				where: {id: ids.pets[0]}, 
				relations: { shelter: true}
			});

			payload = {
				id: pet.id,
				shelterId: pet.shelterId,
				adopted: false,
				age: pet.age+1,
				age_unit: 'm',
				size_variety: 'l',
				type: 'cat',
				name: `${pet.id}_altered`,
			};
		});

		it('responds OK and body should have pet with updated data WHEN admin-user put /pets/:id', async () => {

			const res = await request(server)
				.put(`/pets/${ids.pets[0]}`)
				.set('Authorization', `Bearer ${tokenAdmin}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send(payload);

			Assertions.putPetDone(res, payload);

		});

		it('responds OK and body has "Não Encontrado" when put /pets/:id with non-existent id', async () => {
			const randId = randomUUID();
			const res = await request(server)
				.get(`/pets/${randId}`)
				.set('Authorization', `Bearer ${tokenAdmin}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send({
					...payload,
					id: randId
				});

			Assertions.nonExistentId(res);
		});

		it('responds UNAUTHORIZED when unauthenticated user put /pets/:id', async () => {

			const res = await request(server)
				.put(`/pets/${ids.pets[0]}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send(payload);

			Assertions.unauthenticated(res);
		});

		it('responds FORBIDDEN when shelter-user owner of resource put /pets/:id', async () => {

			const res = await request(server)
				.put(`/pets/${ids.pets[0]}`)
				.set('Authorization', `Bearer ${await findShelterUserAndCreateToken(pet.shelterId)}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send(payload);

			Assertions.notAllowedEntityUpdate(res);
		});

		it('responds FORBIDDEN when tutor-user put /pets/:id', async () => {

			const res = await request(server)
				.put(`/pets/${ids.pets[0]}`)
				.set('Authorization', `Bearer ${tokenTutor}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send(payload);

			Assertions.notAllowedRole(res);
		});

		it('responds FORBIDDEN when shelter-user not onwer of resource put /pets/:id', async () => {

			const res = await request(server)
				.put(`/pets/${ids.pets[0]}`)
				.set('Authorization', `Bearer ${tokenShelter}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send(payload);

			Assertions.restrictedToOwner(res);
		});

		it('responds BADREQUEST When user put /pets/:id with replaced id', async () => {

			const res = await request(server)
				.put(`/pets/${ids.pets[0]}`)
				.set('Authorization', `Bearer ${tokenAdmin}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send({ ...payload, id: randomUUID()});

			Assertions.idReplacement(res);
		});

		it('responds BADREQUEST when user put /pets/:id with replaced shelterId', async () => {

			const res = await request(server)
				.put(`/pets/${ids.pets[0]}`)
				.set('Authorization', `Bearer ${tokenAdmin}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send({ ...payload, shelterId: randomUUID()});

			Assertions.idReplacement(res);
		});

		it('responds BADREQUEST When user put /pets/:id with wrong schema', async () => {

			const res = await request(server)
				.put(`/pets/${ids.pets[0]}`)
				.set('Authorization', `Bearer ${tokenAdmin}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send({ ...payload, any: 'some'});

			Assertions.jsonSchemaError(res);
		});
	});

	describe('Router to update (patch) a pet by id', () => {
		const payload = {
			age_unit: 'm',
			size_variety: 'l',
			name: 'altered',
			adopted: false
		};

		it('responds OK when adm-user patch /pets/:id with any property', async () => {
			const pet = await Pet.findOneOrFail( {where: {id: ids.pets[1]}});

			const res = await request(server)
				.patch(`/pets/${ids.pets[1]}`)
				.set('Authorization', `Bearer ${tokenAdmin}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send(payload);

			Assertions.patchPetDone(res, pet, payload as Pet);
		});

		it('responds OK when shelter-user owner of resource patch /pets/:id with permitted property', async () => {

			const pet = await Pet.findOneOrFail( {where: {id: ids.pets[1]}});
					
			const payload = { type: 'cat'};

			const res = await request(server)
				.patch(`/pets/${ids.pets[1]}`)
				.set('Authorization', `Bearer ${await findShelterUserAndCreateToken(pet.shelterId)}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send(payload);
			
			Assertions.patchPetDone(res, pet, payload as Pet);
		});

		it('responds FORBIDDEN to shelter-user owner of resource patch /pets/:id with any property', async () => {
			const pet = await Pet.findOneOrFail( {where: {id: ids.pets[1]}});
			
			console.debug(pet);

			const res = await request(server)
				.patch(`/pets/${ids.pets[1]}`)
				.set('Authorization', `Bearer ${await findShelterUserAndCreateToken(pet.shelterId)}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send(payload);

			Assertions.notAllowedPropertyUpdate(res);

		});

		it('responds FORBIDDEN to shelter-user not onwer of resource patch /pets/:id', async () => {
			const res = await request(server)
				.patch(`/pets/${ids.pets[1]}`)
				.set('Authorization', `Bearer ${tokenShelter}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send(payload);

			Assertions.restrictedToOwner(res);

		});

		it('responds FORBIDDEN to tutor-user patch /tutor:id', async () => {
			const res = await request(server)
				.patch(`/pets/${ids.pets[1]}`)
				.set('Authorization', `Bearer ${tokenTutor}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send(payload);

			Assertions.notAllowedRole(res);
		});

		it('responds UNAUTHORIZED to unauthenticated-user patch /pets:id', async () => {
			const res = await request(server)
				.patch(`/pets/${ids.pets[1]}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send(payload);

			Assertions.unauthenticated(res);
		});

		it('responds BADREQUEST When a user patch /pets/:id with replaced id', async () => {

			const res = await request(server)
				.patch(`/pets/${ids.pets[1]}`)
				.set('Authorization', `Bearer ${tokenAdmin}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send({ ...payload, id: randomUUID()});

			Assertions.idReplacement(res);
		});

		it('responds BADREQUEST When a user patch /pets/:id with replaced shelterId', async () => {

			const res = await request(server)
				.patch(`/pets/${ids.pets[1]}`)
				.set('Authorization', `Bearer ${tokenAdmin}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send({ ...payload, shelterId: randomUUID()});

			Assertions.idReplacement(res);
		});

		it('responds BADREQUEST When a user patch /pets/:id with wrong schema', async () => {

			const res = await request(server)
				.patch(`/pets/${ids.pets[1]}`)
				.set('Authorization', `Bearer ${tokenAdmin}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send({ ...payload, any: 'some'});

			Assertions.jsonSchemaError(res);
		});

		it('responds BADREQUEST When a user patch /pets/:id with non-existent id', async () => {

			const res = await request(server)
				.patch(`/pets/${randomUUID()}`)
				.set('Authorization', `Bearer ${tokenAdmin}`)
				.set('Content-Type', 'application/json')
				.set('Accept', 'application/json')
				.send(payload);

			Assertions.nonExistentId(res);
		});
	});

	describe('Router do delete a pet by id', () => {

		it('responds UNAUTHORIZED when unauthenticated user delete /pets/:id', async () => {
			const res = await request(server)
				.delete(`/pets/${ids.pets[1]}`);

			console.debug(res.body);
			Assertions.unauthenticated(res);
		});

		it('responds FORBIDDEN when not-admin tutor-user delete /pets/:id', async () => {
			const res = await request(server)
				.delete(`/pets/${ids.pets[1]}`)
				.set('Authorization', `Bearer ${tokenTutor}`);

			console.debug(res.body);
			Assertions.notAllowedRole(res);
		});

		it('responds FORBIDDEN when not-admin shelter-user delete /pets/:id', async () => {
			const res = await request(server)
				.delete(`/pets/${ids.pets[1]}`)
				.set('Authorization', `Bearer ${tokenShelter}`);

			console.debug(res.body);
			Assertions.notAllowedRole(res);
		});

		it('responds OK and body should have delete_date when adm user delete /pets/:id', async () => {

			const res = await request(server)
				.delete(`/pets/${ids.pets[1]}`)
				.set('Authorization', `Bearer ${tokenAdmin}`);

			Assertions.delete(res);
		});

		it('responds BADREQUEST when user delete /pets/:id already deleted', async () => {
			const res = await request(server)
				.delete(`/pets/${ids.pets[1]}`)
				.set('Authorization', `Bearer ${tokenAdmin}`);

			console.debug(res.body);
			Assertions.nonExistentId(res);

		});
		it('responds BADREQUEST when user delete /pets/:id non-existent id', async () => {
			const res = await request(server)
				.delete(`/pets/${randomUUID()}`)
				.set('Authorization', `Bearer ${tokenAdmin}`);

			console.debug(res.body);
			Assertions.nonExistentId(res);
		});
	});
});
