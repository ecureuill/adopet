import request from 'supertest';
import { Server } from 'http';
import { randomUUID } from 'crypto';

import { Assertions } from '../../utils/Assertions';
import { HTTP_RESPONSE } from '../../utils/consts';
import { cleanAndSeedDatabase, cleanDatabase, findUserByShelterId, findUserByTutorId } from '../../utils/database';
import { getToken, getTokens } from '../../utils';

import { User } from '../../../src/entities/User';
import { Role } from '../../../src/types/enums';
import { startServer } from '../../../src/server';
import { closeConnection, openConnection } from '../../../src/database/datasource/data-source';
import { IUser } from '../../../src/types/schemas';

let server: Server;
let tokenAdmin: string;
let tokenShelter: string;
let tokenTutor: string;
let ids: {
	admins: string[], 
	tutors: string[], 
	shelters: string[]
};

beforeAll(async () => {
	server = startServer();
	await openConnection();
	await cleanDatabase();
	ids = await cleanAndSeedDatabase(2);
	({ tokenShelter, tokenAdmin, tokenTutor } = await getTokens());
});

afterAll(() => {
	server.close();
	closeConnection();
});


describe('Router to signup for admin User', () => {
	it('Responds CREATED and body should have user object to post /signup', async () => {
		const payload = {
			name: 'admin test',
			email: 'admin_test@mail.com',
			password: '12345678'
		};

		const result = {
			email: payload.email,
			name: payload.name,
			role: 'admin',
			phone: null,
			city: null,
			state: null,
			delete_date: null,
		};

		const res = await request(server)
			.post('/signup')
			.send(payload)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json');

		console.debug(res.body);
		Assertions.created(res, result);
	});

	it('responds BADREQUEST to post /signup for alerady registered email', async () => {
		const payload = {
			name: 'admin test',
			email: 'admin_test@mail.com',
			password: '12345678'
		};

		const res = await request(server)
			.post('/signup')
			.send(payload)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json');

		console.debug(res.body);
		Assertions.signUPNotAllowed(res);
	});

	it('responds BADREQUEST to post /signup wrong json schema', async () => {
		const payload = {
			a: 'admin test',
			b: 'admin_test1@mail.com',
		};

		const res = await request(server)
			.post('/signup')
			.send(payload)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json');

		console.debug(res.body);
		Assertions.jsonSchemaError(res);
	});
});

describe('Router to login', () => {

	it('responds OK and body should have token to post /login', async () => {
		const payload = {
			email: 'admin@mail.com',
			password: '12345678'
		};

		const res = await request(server)
			.post('/login')
			.send(payload)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json');

		console.debug(res.body);
		expect(res.statusCode).toBe(HTTP_RESPONSE.OK);
		expect(res.get('Content-Type')).toContain('application/json');
		expect(res.body['token']).not.toBeUndefined();
	});

	it('responds UNAUTHORIZED to post /login with wrong credentials', async () => {
		const payload = {
			email: 'admin@mail.com',
			password: '10345678'
		};

		const res = await request(server)
			.post('/login')
			.send(payload)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json');

		console.debug(res.body);
		expect(res.statusCode).toBe(HTTP_RESPONSE.Unauthorized);
		expect(res.body['message']).toBe('Invalid credentials');
	});

	it('responds UNAUTHORIZED to post /login with not registered email', async () => {
		const payload = {
			email: 'admin_test@mail.com',
			password: '12345678'
		};

		const res = await request(server)
			.post('/login')
			.send(payload)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json');

		console.debug(res.body);
		expect(res.statusCode).toBe(HTTP_RESPONSE.Unauthorized);
		expect(res.body['message']).toBe('Not');
	});

	it('responds BADREQUEST to post /login with wrong Schema', async () => {
		const payload = {
			a: 'admintest@mail.com',
			b: '12345678',
			anyProperty: 'something'
		};

		const res = await request(server)
			.post('/login')
			.send(payload)
			.set('Content-Type', 'application/json')
			.set('Accept', 'application/json');

		console.debug(res.body);
		Assertions.jsonSchemaError(res);
	});
});

describe('Router to retrive users', () => {
	
	it('responds OK and body should have a list of users when admin user get /users', async () => {
		const res = await request(server)
			.get('/users')
			.set('Authorization', `Bearer ${tokenAdmin}`);

		console.debug(res.body);
		Assertions.retrieveCompleteListEntities(res);
	});

	it('responds OK and body should have a list with one user when tutor user to get /users', async () => {
		const res = await request(server)
			.get('/users')
			.set('Authorization', `Bearer ${tokenTutor}`);

		console.debug(res.body);
		Assertions.retrieveRestrictedListOwnedEntities(res);
	});

	it('responds OK and body should have a list with one user when shelter user to get /users', async () => {
		const res = await request(server)
			.get('/users')
			.set('Authorization', `Bearer ${tokenShelter}`);

		console.debug(res.body);
		Assertions.retrieveRestrictedListOwnedEntities(res);
	});

	it('responds UNAUTHORIZED to get /users when unauthenticated', async () => {
		const res = await request(server)
			.get('/users');

		console.debug(res.body);
		Assertions.unauthenticated(res);
	});
});

describe('Router to retrive user by id', () => {
	let user: User;

	beforeAll(async () => {
		user = await User.findOneByOrFail({email: 'tutor@mail.com'});
	});

	it('responds OK and body should have one user when admin user get /users/:id', async () => {
		
		const res = await request(server)
			.get(`/users/${user.id}`)
			.set('Authorization', `Bearer ${tokenAdmin}`);

		console.debug(res.body);
		Assertions.retrieveEntity(res, user);
	});

	it('responds OK and body should have one user when tutor-user owner of the resource get /users/:id', async () => {
		
		const res = await request(server)
			.get(`/users/${user.id}`)
			.set('Authorization', `Bearer ${tokenTutor}`);

		const { id, ...partialUser } = user;

		console.debug(res.body);
		Assertions.retrieveEntity(res, partialUser);
	});

	it('responds OK and body should have one user when shelter-user owner of the resource get /users/:id', async () => {
		
		const user = await User.findOneByOrFail({email: 'abrigo@mail.com'});
		
		const res = await request(server)
			.get(`/users/${user.id}`)
			.set('Authorization', `Bearer ${tokenShelter}`);

		const { id, ...partialUser } = user;

		console.debug(res.body);
		Assertions.retrieveEntity(res, partialUser);
	});

	it('responds OK and body should return "NÃ£o Encontrado" when user get /users/:id with non-existent id', async () => {
		const res = await request(server)
			.get(`/users/${randomUUID()}`)
			.set('Authorization', `Bearer ${tokenAdmin}`);

		console.debug(res.body);
		Assertions.nonExistentId(res);
	});

	it('responds UNAUTHORIZED when unauthenticated user get /user:id', async () => {
		const res = await request(server)
			.get(`user/${user.id}`);

		Assertions.unauthenticated(res);
	});

	it('responds FORBIDDEN when shelter-user not owner of resource get /users/:id', async () => {
		const res = await request(server)
			.get(`/users/${user.id}`)
			.set('Authorization', `Bearer ${tokenShelter}`);

		console.debug(res.body);
		Assertions.restrictedToOwner(res);
	});

	it('responds FORBIDDEN when tutor-user not owner of resource get /users/:id', async () => {
		
		const res = await request(server)
			.get(`/users/${ids.tutors[0]}`)
			.set('Authorization', `Bearer ${tokenTutor}`);

		console.debug(res.body);
		Assertions.restrictedToOwner(res);
	});
});

describe('Router to update (put) user', () => {
	let payload: IUser;
	
	beforeAll(async () => {
		const user = await User.findOneByOrFail({id: ids.admins[0]});

		payload = {
			id: user.id,
			email: 'altered@mail.com',
			name: 'altered',
			password: 'altered1',
			role: Role.SHELTER,
			city: 'altered',
			state: 'AL',
			phone: '11.9999-9999',
			delete_date: ''
		};
	});

	it('responds OK and body should have user with new data when admin-user put /users/:id', async () => {
		
		const res = await request(server)
			.put(`/users/${payload.id}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.send(payload);

		console.debug(res.body);
		Assertions.putUserDone(res, payload);
	});

	it('responds UNAUTHORIZED when unauthenticated-user put /users/:id', async () => {
		
		const res = await request(server)
			.put(`/users/${payload.id}`)
			.send(payload);

		console.debug(res.body);
		Assertions.unauthenticated(res);
	});
	
	it('responds BADREQUEST when user put /users/:id with non-existent id', async () => {

		const res = await request(server)
			.put(`/users/${randomUUID}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.send(payload);

		console.debug(res.body);
		Assertions.nonExistentId;
	});

	it('responds BADREQUEST when user put /users/:id with wrong json schema', async () => {

		const res = await request(server)
			.put(`/users/${payload.id}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.send({
				id: payload.id,
				any: 'a text',
				some: 9,
				maybe: true
			});

		console.debug(res.body);
		Assertions.jsonSchemaError(res);
	});

	it('responds BADREQUEST when user put /users/:id with replaced id ', async () => {
		const res = await request(server)
			.put(`/users/${payload.id}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.send({...payload, id: randomUUID()});

		Assertions.idReplacement(res);
	});
	
	it('responds FORBIDDEN when tutor-user owned of resource put /users/:id', async () => {
		
		const user = await findUserByTutorId(ids.tutors[0]);

		const res = await request(server)
			.put(`/users/${user.id}`)
			.set('Authorization', `Bearer ${getToken(user.id, Role.TUTOR)}`)
			.send({...payload, id: user.id});

		Assertions.notAllowedEntityUpdate(res);
	});
	
	it('responds FORBIDDEN when shelter-user owned of resource put /users/:id', async () => {
		const user = await findUserByShelterId(ids.shelters[0]);
		
		const res = await request(server)
			.put(`/users/${user.id}`)
			.set('Authorization', `Bearer ${getToken(user.id, Role.SHELTER)}`)
			.send({...payload, id: user.id});

		Assertions.notAllowedEntityUpdate(res);
	});

	it('responds FORBIDDEN when token-user not owner of resource put /users/:id', async () => {
		const res = await request(server)
			.put(`/users/${payload.id}`)
			.set('Authorization', `Bearer ${tokenTutor}`)
			.send(payload);

		Assertions.restrictedToOwner(res);
	});

	it('responds FORBIDDEN when shelter-user not owner of resource put /users/:id', async () => {
		const res = await request(server)
			.put(`/users/${payload.id}`)
			.set('Authorization', `Bearer ${tokenShelter}`)
			.send(payload);

		Assertions.restrictedToOwner(res);
	});
});

describe('Router to update (patch) user', () => {
	let user: User;
	
	const payload = { 
		email: 'abrigo-altered@gmail.com',
		phone: '11 9999-9999',
		role: Role.TUTOR
	};
	
	beforeAll(async () => {
		user = await User.findOneByOrFail({id: ids.admins[1]});
	});

	it('responds OK and body have user with new data when admin-user patch /users/:id', async () => {
		
		const res = await request(server)
			.patch(`/users/${user.id}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.send(payload);

		console.debug('user');
		console.debug(user);
		console.debug(res.body);
		Assertions.patchUserDone(res, user,payload as User);
	});

	it('responds OK and body have user with new data when tutor-user owner of resource patch /users/:id', async () => {
		const payload = {phone: '11 9999-9999'};
		const tutorUser = await findUserByTutorId(ids.tutors[1]);

		const res = await request(server)
			.patch(`/users/${tutorUser.id}`)
			.set('Authorization', `Bearer ${getToken(tutorUser.id, Role.TUTOR)}`)
			.send(payload);

		console.debug(res.body);
		Assertions.patchUserDone(res, tutorUser, payload as User);
	});

	it('responds OK and body have user with new data when shelter-user owner of resource patch /users/:id', async () => {
		
		const payload = {phone: '11 9999-9999'};

		const shelterUser = await findUserByShelterId(ids.shelters[1]);

		const res = await request(server)
			.patch(`/users/${shelterUser.id}`)
			.set('Authorization', `Bearer ${getToken(shelterUser.id, Role.SHELTER)}`)
			.send(payload);

		console.debug(res.body);
		Assertions.patchUserDone(res, shelterUser,payload as User);
	});
	
	it('responds BADREQUEST to patch /users/:id with wrong json schema', async () => {

		const res = await request(server)
			.patch(`/users/${user.id}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.send({
				any: 'a text',
				some: 9,
				maybe: true
			});

		console.debug(res.body);
		Assertions.jsonSchemaError(res);
	});

	it('responds BADREQUEST to patch /users/:id when attempts to update id ', async () => {
		const res = await request(server)
			.patch(`/users/${user.id}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.send({id: randomUUID()});

		Assertions.idReplacement(res);
	});
	
	it('responds FORBIDDEN when tutor-user not owner of resource patch /users/:id', async () => {
		const res = await request(server)
			.patch(`/users/${user.id}`)
			.set('Authorization', `Bearer ${tokenTutor}`)
			.send(payload);

		Assertions.restrictedToOwner(res);
	});
	
	it('responds FORBIDDEN when shelter-user not owner of resource patch /users/:id', async () => {
		const res = await request(server)
			.patch(`/users/${user.id}`)
			.set('Authorization', `Bearer ${tokenShelter}`)
			.send(payload);

		Assertions.restrictedToOwner(res);
	});
	
	it('responds FORBIDDEN when tutor-user owner of resource patch /users/:id with not permitted properties', async () => {
		
		const tutorUser = await findUserByTutorId(ids.tutors[1]);

		const res = await request(server)
			.patch(`/users/${tutorUser.id}`)
			.set('Authorization', `Bearer ${getToken(tutorUser.id, Role.TUTOR)}`)
			.send(payload);

		Assertions.notAllowedPropertyUpdate(res);
	});
	
	it('responds FORBIDDEN when shelter-user owner of resource patch /users/:id with not permitted properties', async () => {
		
		const shelterUser = await findUserByShelterId(ids.shelters[1]);

		const res = await request(server)
			.patch(`/users/${shelterUser.id}`)
			.set('Authorization', `Bearer ${getToken(shelterUser.id, Role.SHELTER)}`)
			.send(payload);

		Assertions.notAllowedPropertyUpdate(res);
	});

	it('responds UNAUTHORIZED when unauthenticated-user patch /users/:id', async () => {
		const res = await request(server)
			.patch(`/users/${user.id}`)
			.send(payload);

		Assertions.unauthenticated(res);
	});

	it('responds BADREQUEST when user put /users/:id with non-existent id', async () => {

		const res = await request(server)
			.patch(`/users/${randomUUID}`)
			.set('Authorization', `Bearer ${tokenAdmin}`)
			.send(payload);

		console.debug(res.body);
		Assertions.nonExistentId(res);
	});
});

describe('Router to delete user', () => {
	it('responds UNAUTHORIZED when unauthenticated-user delete /users/:id', async () => {
		const res = await request(server).delete(`/users/${ids.admins[0]}`);

		console.debug(res.body);
		Assertions.unauthenticated(res);
	});

	it('responds FORBIDDEN tutor-user owner of resource delete /users/:id', async () => {
		
		const res = await request(server)
			.delete(`/users/${ids.tutors[0]}`)
			.set('Authorization', `Bearer ${getToken(((await findUserByTutorId(ids.tutors[0])).id), Role.TUTOR)}`);

		console.debug(res.body);
		Assertions.notAllowedRole(res);
	});

	it('responds FORBIDDEN shelter-user owner of resource delete /users/:id', async () => {
		
		const res = await request(server)
			.delete(`/users/${ids.shelters[0]}`)
			.set('Authorization', `Bearer ${getToken((await findUserByShelterId(ids.shelters[0])).id, Role.SHELTER)}`);

		console.debug(res.body);
		Assertions.notAllowedRole(res);
	});

	it('responds Ok when admin-user delete /users/:id', async () => {
		const res = await request(server)
			.delete(`/users/${ids.admins[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`);

		console.debug(res.body);
		Assertions.delete(res);
	});

	it('responds BadRequest to delete /users/:id already deleted', async () => {
		const res = await request(server)
			.delete(`/users/${ids.admins[0]}`)
			.set('Authorization', `Bearer ${tokenAdmin}`);

		console.debug(res.body);
		Assertions.nonExistentId(res);
	});
});